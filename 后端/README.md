# REDIS

Redis是一个**基于内存**，通过**键值对**(**key-value**)的形式来存储数据的**NoSQL**数据库。

## 数据类型

- string：{"name":"z"} 用于频繁读取
- hash：userinfo:{"name":"z","age":18} 用于频繁写入修改，对象存储和配置信息存储
- list：FIFO先进先出原则，常用于队列
- set：无序集合，文章标签和好友关系
- zset：有序集合，常用于排行榜和统计

## 数据持久化方式

RDB快照，恢复数据快，但是数据可能会丢失，一致性和完善性差

AOF追加的模式写入文件，每秒触发数据，数据也可能丢失，可手动更改频率，默认关闭，数据恢复慢，完整性好

## 常见问题与解决方案

缓存穿透，缓存击穿，缓存雪崩

# MySQL

## 索引

**索引是什么**：索引是为了加速对表中数据行的检索而创建的一种分散存储的数据结构(硬盘级)。

**为什么要用索引**

- 索引能极大的减少存储引擎需要扫描的数据量。
- 索引可以把随机IO变成顺序IO。
- 索引可以帮助我们在进行分组、排序等操作时，避免使用临时表。

## 索引为什么使用B+tree

- 二叉树和红黑树，树的分支深，不平衡，IO代价高
- hash索引，每一行数据的地址指针对应一个hash，一对一，非常快，但是没办法分页
- B-tree，数据分布在各个节点，访问性能不稳定，分页不好做
- B+tree，数据存放在根节点，访问性能稳定，添加了双向链表，解决了分页问题

## 聚簇索引和非聚簇索引的区别

聚簇索引：索引和主键在一个文件，节点存放的是主键和数据，主键下面就是数据，会索引覆盖

非聚簇索引：索引和数据分开的，节点存放主键值，然后通过主键值再去回表查找数据，如果只查找索引本身，就不会回表

## 索引分类

主键索引，唯一索引，联合索引(a,b,c) => a, ab, abc，普通索引，全文索引（仅Myisam支持，text，fulltext)

## 索引失效的场景

- 数据类型不一致
- 字段有函数操作
- 使用不等于查询
- like时左边是通配符
- 不符合最左前缀原则

## 事务的隔离级别

读未提交：脏读，不可重复读，幻读

读已提交：不可重复读，幻读

可重复读：innodb默认等级，幻读

可串行化：解决了所有的问题，但是吞吐率不高，容易造成数据库阻塞

## innoDB和MyISAM区别

innoDB支持事务，MyISAM不支持

InnoDB支持行级锁，表锁，而MyISAM只支持表锁

InnoDB支持外键，而MyISAM不支持外键

innoDB必须有主键，而MyISAM可以没有

InnoDB5.7之前不支持全文索引，MyISAM支持

# Linux

1.查询内存命令

free

内存信息：

- 总内存（Total）：显示系统的总内存大小。
- 已使用内存（Used）：显示当前已被分配和使用的内存大小。
- 剩余内存（Free）：显示当前剩余可用的内存大小。
- 共享内存（Shared）：显示被多个进程共享的内存大小。
- 缓存（Buffers）：显示用于缓存文件系统数据的内存大小。
- 缓冲区（Cached）：显示用于缓冲磁盘写操作的内存大小。

内存单位：

- 默认情况下，free命令以千字节（Kilobytes，KB）为单位显示内存大小。
- 可以使用"-b"参数以字节（Bytes）为单位显示内存大小。
- 可以使用"-k"参数以千字节为单位显示内存大小。
- 可以使用"-m"参数以兆字节（Megabytes，MB）为单位显示内存大小。
- 可以使用"-g"参数以吉字节（Gigabytes，GB）为单位显示内存大小。

2.查询linux大于100M的文件

```shell
find / -type f -size +100M
```

3.查询php-fpm进程数或列出所有php-fpm进程

```shell
ps aux | grep -c php-fpm
ps aux | grep  php-fpm
```

# HTTP

1.get和post区别

- 语意上，get为获取，post为新增
- 参数位置，get在url中携带数据，post在body中传输，这个只是约定，http协议并没有规定，get也可以通过body传输数据
- 长度，每个浏览器规定url携带的数据长度不一样，post没有限制，http协议也未规定
- 安全，get在url中携带比较明显，post在body中携带比较隐蔽这样方式说post比get安全未免太牵强，用https传输和数据加密来说比较安全
- 数据包，get请求的时候把 header和data一起发送，而post是先发送header，服务器响应100 continue 之后再发data，服务器再响应200
- 幂等性，get幂等（get回退无害），post不幂等（post会重新提交一次）
- 缓存，浏览器发送get的时候会有记录，post没有

# 计算机经典问题

## 浮点数标准无法精确表示0.1

0.1在计算机中用0和1存储的，根据IEEE754标准，0.1转化成二进制也是无限循环的，但是存储的位数有限，所以会导致精度丢失。永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。
