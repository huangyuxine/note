# 创建型

## 简单工厂模式

> 简单工厂只是为客户端生成一个实例，而不会向客户端公开任何实例化逻辑。
>
> 每个具体工厂类只能创建一个具体产品类的实例。

```PHP
class Book
{
    protected $author;

    protected $name;

    public function __construct(string $name, string $author)
    {
        $this->name = $name;
        $this->author = $author;
    }
}

class BookFactory
{
    public static function makeBook(string $name, string $author)
    {
        return new Book($name, $author);
    }
}
```

## 工厂方法模式

> 工厂类负责创建的对象的种类由子类决定

```php
interface Interviewer
{
    public function askQuestions();
}

class Developer implements Interviewer
{
    public function askQuestions()
    {
        echo 'Asking about design patterns!';
    }
}

class CommunityExecutive implements Interviewer
{
    public function askQuestions()
    {
        echo 'Asking about community building';
    }
}
```

```php
abstract class HiringManager
{
    abstract protected function makeInterviewer(): Interviewer;

    public function takeInterview()
    {
        $interviewer = $this->makeInterviewer();
        $interviewer->askQuestions();
    }
}
```

现在任何子类都可以继承并提供所需的`Interviewer`

```php
class DevelopmentManager extends HiringManager
{
    protected function makeInterviewer(): Interviewer
    {
        return new Developer();
    }
}

class MarketingManager extends HiringManager
{
    protected function makeInterviewer(): Interviewer
    {
        return new CommunityExecutive();
    }
}
```

## 抽象工厂模式

> 为创建一组相关或者是相互依赖的对象提供一个接口，而不需要指定它们的具体类。

```php
interface Computer
{
    public function getDescription();
}

class NotebookComputer implements Computer
{
    public function getDescription()
    {
        echo 'Notebook';
    }
}

class DesktopComputer implements Computer
{
    public function getDescription()
    {
        echo 'Desktop';
    }
}

interface Repairman
{
    public function getDescription();
}

class NotebookRepairman implements Repairman
{
    public function getDescription()
    {
        echo 'notebook repairman';
    }
}

class DesktopRepairman implements Repairman
{
    public function getDescription()
    {
        echo 'desktop repairman';
    }
}


interface ComputerFactory
{
    public function makeComputer();
    public function makeRepairman();
}

class NotebookComputerFactory implements ComputerFactory
{
    public function makeComputer()
    {
        return new NotebookComputer();
    }

    public function makeRepairman()
    {
        return new NotebookRepairman();
    }
}

class DesktopComputerFactory implements ComputerFactory
{
    public function makeComputer()
    {
        return new DesktopComputer();
    }

    public function makeRepairman()
    {
        return new DesktopRepairman();
    }
}
```

## 建造者模式

> 建造者模式是一种创建对象的软件设计模式，其目的是找到伸缩构造器反模式的解决方案。
>
> 当创建是一步过程时，将使用工厂模式，而当创建是多步骤过程时，将使用建造者模式。

```php
class Rougamo
{
    protected $pepper;

    protected $meat;

    protected $garlic;

    public function __construct(RougamoBuilder $rougamoBuilder)
    {
        $this->pepper = $rougamoBuilder->pepper;
        $this->meat = $rougamoBuilder->meat;
        $this->garlic = $rougamoBuilder->garlic;
    }
}


class RougamoBuilder
{
    public $pepper;

    public $meat;

    public $garlic;

    public function addPepper()
    {
        $this->pepper = true;
        return $this;
    }

    public function addMeat()
    {
        $this->meat = true;
        return $this;
    }

    public function addGarlic()
    {
        $this->garlic = true;
        return $this;
    }

    public function build(): Rougamo
    {
        return new Rougamo($this);
    }
}


$rougamoBuilder = (new RougamoBuilder())
    ->addPepper()
    ->addGarlic()
    ->addMeat()
    ->build();
```

## 原型模式

>相比正常创建一个对象，首先创建一个原型，然后克隆它会更节省开销

```php
class Article
{
    protected $title;
    protected $content;

    public function __construct($title, $content)
    {
        $this->title = $title;
        $this->content = $content;
    }

    public function getTitle()
    {
        return $this->title;
    }

    public function setTitle($title)
    {
        $this->title = $title;
    }

    public function getContent()
    {
        return $this->content;
    }

    public function setContent($content)
    {
        $this->content = $content;
    }

    public function __clone()
    {
        
    }
}

$articlePrototype = new Article('Default Title', 'Default Content');

// 克隆原型并修改属性
$article1 = clone $articlePrototype;
$article1->setTitle('Article 1 Title');
$article1->setContent('Article 1 Content');

$article2 = clone $articlePrototype;
$article2->setTitle('Article 2 Title');
$article2->setContent('Article 2 Content');

echo $article1->getTitle();
echo $article2->getTitle();
```

## 单例模式

> 确保只有特定类的一个对象被创建。
>
> 反面模式。

```php
final class President
{
    private static $instance;

    private function __construct()
    {
       
    }

    public static function getInstance(): President
    {
        if (!self::$instance) {
            self::$instance = new self();
        }

        return self::$instance;
    }

    private function __clone()
    {
        
    }

    private function __wakeup()
    {
       
    }
}
```

# 结构型

## 适配器模式

> 适配器模式允许您在适配器中包装其他不兼容的对象，使其与另一个类兼容。

```php
<?php

namespace Db;

interface UnifyDatabase
{
    function connect($host, $user, $password, $dbname);

    function query($sql);

    function close();
}

class Mysqli implements UnifyDatabase
{
    protected $conn;

    public function connect($host, $user, $password, $dbname)
    {
        $conn = mysqli_connect($host, $user, $password);
        mysqli_select_db($conn, $dbname);
        $this->conn = $conn;
    }

    public function query($sql)
    {
        $result = mysqli_query($this->conn, $sql);
        return $result;
    }

    public function close() {
        mysqli_close($this->conn);
    }
}

// $mysqli = new Mysqli();
// $mysqli->connect('127.0.0.1', 'root', '123123', 'test');
// $result = $mysqli->query('show database');
// $mysqli->close();

class PDO implements UnifyDatabase
{
    protected $conn;

    public function connect($host, $user, $password, $dbname)
    {
        try {
            $conn = new \PDO("mysql:host=$host;dbname=$dbname;", $user, $password);
        } catch (\Throwable $th) {
            echo $th->getMessage();
        }
        $this->conn = $conn;
    }

    public function query($sql)
    {
        $result = $this->conn->query($sql)->fetchAll(\PDO::FETCH_ASSOC);
        return $result;
    }

    public function close() {
        $this->conn = null;
    }
}



$pdo = new PDO();
$pdo->connect('127.0.0.1', 'root', '123123', 'test');
$result = $pdo->query('show tables;');
$pdo->close();

var_dump($result);
```

## 桥梁模式

> 通过将抽象与实现分离，使得可以独立地扩展或修改抽象的行为和实现的细节，而不影响对方。

```php
interface Cloth
{
    public function __construct(Style $style);

    public function getDescription();
}


interface Style
{
    public function getStyle();
}

class Jeans implements Cloth
{
    protected $style;

    public function __construct(Style $style)
    {
        $this->style = $style;
    }

    public function getDescription()
    {
        echo 'jeans ' . $this->style->getStyle();
    }
}

class Casual
{
    protected $style;

    public function __construct(Style $style)
    {
        $this->style = $style;
    }

    public function getDescription()
    {
        echo 'casual ' . $this->style->getStyle();
    }
}

class WorkStyle implements Style
{
    public function getStyle()
    {
        return 'work';
    }
}

class OutsideStyle implements Style
{
    public function getStyle()
    {
        return 'outside';
    }
}

$workStyle = new WorkStyle();

$jeans = new Jeans($workStyle);
$jeans->getDescription();
```

